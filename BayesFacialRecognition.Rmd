---
title: "BayesFacialRecognition"
author: "Anita Vrins, Ronja Rönnback, Louis Sillekens"
date: "2023-11-18"
output: html_document
---

# Bayesian Modelling of Cognitive Processes Group Project

## Facial Recognition of Public Figures
By Anita Vrins, Ronja Ronnback, and Louis Sillekens

In this rmarkdown document the code of our project is located. Some comments exist, but for a better explanation, please read our separate report.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# set the working directory here for the entire notebook
#knitr::opts_knit$set(root.dir = ("/Users/ronjaronnback/Documents/GitHub/BayesianFaceRecognition"))
knitr::opts_knit$set(root.dir = '("C:/Users/louis/Documents/University/Master (TiU)/Year 2/Courses/BayesModels/FacialRec/BayesianFaceRecognition')
```

```{r imports, include=FALSE, echo=FALSE}
# Loading packages --------------------------------------------------------

library(tidyr)
library(dplyr)
options(mc.cores = parallel::detectCores())
library(bcogsci)
library(extraDistr)
library(bayesplot)
library(ggplot2)
library(rstan)
library(posterior)
rstan_options(auto_write = FALSE)

```

### Load the data
```{r load data, message=FALSE}
# Load Data ---------------------------------------------------------------
data <-read.csv("data/outcome_data.csv")

# define min-max scaling function
min_max_scale <- function(x){(x-min(x))/(max(x) - min(x))}

# min-max scale and center data on 0
data$C_TotalPageViews <- min_max_scale(data$TotalPageViews) - 0.5

```

### Base Multinomial Processing Tree Model 
```{r preprocessing, message=FALSE}
# Find probabilities for each branch --------------------------------------
value_counts <- table(data$outcome)
value_counts 

p_true <- .58
q_true <- .66
r_true <- .23

# Declaring Functions ---------------------------------------------------------

NotRecognised <-function(p,q,r) # NR
  1 - p

RecognisedAndNamed <-function(p,q,r) #C
  p * q

TipOfTongue <- function(p,q,r) #TT
  p * (1 - q) * r

RecognisedNotNamed <- function(p,q,r) #RNN
  p * (1 - q) * (1 - r)

# Creating a Dataframe -------------------------------------------------

theta_NR <- NotRecognised(p_true, q_true, r_true)
theta_C <- RecognisedAndNamed(p_true, q_true, r_true)
theta_TT <- TipOfTongue(p_true, q_true, r_true)
theta_RNN <- RecognisedNotNamed(p_true, q_true, r_true)

# generate data vector of probabilities
Theta <- tibble(theta_NR,
    theta_C,
    theta_TT,
    theta_RNN)

# generate values of a multinomial distribution of responses given Theta
N_trials <- 200
(ans <- rmultinom(1, N_trials, c(Theta)))
```
#### Fit Base MPT Model
```{r base model, message=FALSE}
# BASE Stan Model --------------------------------------------------------------

data_face <-  list(N_trials = N_trials,
                   ans = c(ans)) 

fit_face <- stan("Facial.stan", data = data_face)


# Model Inspection --------------------------------------------------------
print(fit_face, pars = c("p", "q", "r"))


as.data.frame(fit_face) %>%
  select(c("p","q","r")) %>%
  mcmc_recover_hist(true = c(p_true, q_true, r_true)) +
  coord_cartesian(xlim = c(0, 1))

print(fit_face, pars = c("theta")) # nice & close to the derived "true" values!

# remove model because otherwise Ronja's laptop crashes
remove(fit_face)
```

### Hierarchical Multinomial Processing Tree Model ON SIMULATED DATA
```{r simulated data preparation, message=FALSE}
N_item <- 20 # number trials per subject
N_subj <- 176 # number of subjects
N_obs <- N_item * N_subj 

subj <- rep(1:N_subj, each = N_item)
trial_number <- rep(1:N_item, time = N_subj)
# make approximate distribution for complexity (fame) and center it

complexity <- min_max_scale(rep(rlnorm(N_item, meanlog = 0, sdlog = 1), 
                                      times = N_subj)) - 0.5

# define simulated true parameters
r_true <- 0.23
p_true <- .58
q_true <- .66

tau_u_p <- 1.1
u_p <- rnorm(N_subj, 0, tau_u_p)
p_true_u <- qlogis(p_true) + u_p[subj]
alpha_p <- 0
beta_p <- 1
p_true <- plogis(alpha_p + p_true_u + complexity*beta_p)

alpha_q <- 0
beta_q <- 1
q_true <- plogis(alpha_q + complexity * beta_q)

theta_NR <- NotRecognised(p_true, q_true, r_true)
theta_C <- RecognisedAndNamed(p_true, q_true, r_true)
theta_TT <- TipOfTongue(p_true, q_true, r_true)
theta_RNN <- RecognisedNotNamed(p_true, q_true, r_true)

# generate data vector of probabilities
theta_h <- matrix(
  c(theta_NR,
    theta_C,
    theta_TT,
    theta_RNN),
  ncol = 4)

# generate values of a multinomial distribution of responses given Theta
(ans <- rcat(N_obs,theta_h))

# make tibble of our real data
(sim_exp <- tibble(subj = subj,
                   item = trial_number,
                   complexity = complexity,
                   w_ans = ans)) 

# make list of our experiment data
sim_exp_list <-  list(onlyprior = 0,
                      N_obs = nrow(sim_exp),
                      w_ans = sim_exp$w_ans,
                      N_subj = max(sim_exp$subj),
                      subj = sim_exp$subj,
                      complexity = sim_exp$complexity)
```
#### Fit model
```{r sim hierarchical model, message=FALSE}
# get STAN model
mpt_hierarch_sim <- stan("HierarchicalFacial.stan", data = sim_exp_list)
```

Let's see the output:

```{r sim hierarchical model output, message=FALSE}
print(mpt_hierarch_sim,
      pars = c("r", "tau_u", "alpha_p", "beta_p", "alpha_q", "beta_q"))
# parameter recovery pretty good! Only alpha_p different

# see if we converged: Looks good!
traceplot(mpt_hierarch_sim, pars=c("r", "alpha_p", "beta_p", "alpha_q", "beta_q"))

# posterior predictive checks for simulated data
as.data.frame(mpt_hierarch_sim) %>%
  select(r, alpha_p, beta_p, alpha_q, beta_q) %>%
  mcmc_recover_hist(true = c(r_true, alpha_p, beta_p, alpha_q, beta_q))
```

It looks like we converge, and recover the parameters quite well.

```{r sim hierarchical model, message=FALSE, echo=FALSE}
# remove model because otherwise Ronja's laptop crashes
remove(mpt_hierarch_sim)
```


### Hierarchical Multinomial Processing Tree Model ON REAL DATA
```{r hierarchical model, message=FALSE}
# HIERARCHICAL Stan Model --------------------------------------------------

N_item <- 20 # number trials per subject
N_subj <- 176 # number of subjects
N_obs <- N_item * N_subj 

# make tibble of our real data
(exp <- tibble(subj = data$participant,
               item = data$trial_number,
               complexity = data$C_TotalPageViews,
               w_ans = data$outcome)) 

# make list of our experiment data
exp_list_h <-  list(onlyprior = 0,
                    N_obs = nrow(exp),
                    w_ans = exp$w_ans,
                    N_subj = max(exp$subj),
                    subj = exp$subj,
                    complexity = exp$complexity)
# get STAN model
mpt_hierarch <- stan("HierarchicalFacial.stan", data = exp_list_h)
```

Let's see the output:

```{r hierarchical model output, message=FALSE}
print(mpt_hierarch,
      pars = c("r", "tau_u", "alpha_p", "beta_p", "alpha_q", "beta_q"))

# see if we converged:
traceplot(mpt_hierarch)
```

### Posterior Predictive Checks of Hierarchical Model

 NR  - 1 - "I did not recognise the person"
 C   - 2 - "I got it right"                            
 TT  - 3 - "I got it wrong, but the correct name was “on the tip of my tongue”"
 RNN - 4 - "I recognised the person, but I could not remember their name"
 
```{r posterior, message=FALSE}
# TEST POSTERIOR PREDICTIVE CHECK 
# ------------------------------------------------------------------------------
mcmc_hist(mpt_hierarch, pars = c("r", "alpha_p", "beta_p", "alpha_q", "beta_q"))

# as.data.frame(mpt_hierarch) %>%
#   select(r, alpha_p, beta_p, alpha_q, beta_q) %>%
#   mcmc_recover_hist(true = c(0.25, 2.5, 7, 1.5, 4))

# bar plot as posterior predictive check
gen_data <- rstan::extract(mpt_hierarch)$pred_w_ans
ppc_bars(exp$w_ans, gen_data) +
  ggtitle ("Hierarchical model") 

# same but grouped by subject, doesn't really look like anything now with this many subjects
temp <- head(unique(exp$subj), 10)
exp_subset <- exp[exp$subj%in%temp,]

dim(exp)
dim(exp_subset)
dim(gen_data)

# subset data & preds in the same direction (if only 200 data rows, make sure to remove COLUMNS in gen_data to match 200!)

#ppc_bars_grouped(exp$w_ans, 
#                 gen_data, group = exp$subj) +
#  ggtitle ("By-subject plot for the hierarchical model")
```
```{r posterior fame, message=FALSE}

# MAKE POSTERIOR CHECK FOR FAMOUS OR NOT FAMOUS PEOPLE
fame<- factor(ifelse(data$C_TotalPageViews>0, "Very Famous", "Less Famous"))

# want frequency, not counts!
ppc_bars_grouped(exp$w_ans, gen_data, group = fame, freq = FALSE) + 
  ggtitle ("Plot for the hierarchical model for famous or less famous items")# +
  #xaxis_text(c("NR", "C","ToT","RNN"))


```


```{r posterior fame, message=FALSE}

# MAKE POSTERIOR CHECK FOR FAMOUS OR NOT FAMOUS PEOPLE
MJNAorNOT <- factor(ifelse(data$name=="Michael Jackson", "Michael Jackson", 
                         ifelse(data$name=="Neil Armstrong", "Neil Armstrong", 
                         "Other Celebrities")))

# want frequency, not counts!
ppc_bars_grouped(exp$w_ans, gen_data, group = MJNAorNOT, freq = FALSE) + 
  ggtitle ("Plot for the hierarchical model for Michael Jackson, Neil Armstrong or other celebrities")


```



